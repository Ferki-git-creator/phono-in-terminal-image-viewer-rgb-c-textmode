name: PIT CI/CD

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  build-test:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        arch: [x64, arm64] # x64 for Intel/AMD, arm64 for Apple Silicon/ARM Linux
        exclude:
          # Windows runners do not natively support arm64 builds without specific cross-compilers/toolchains
          - os: windows-latest
            arch: arm64
          # macos-latest is ARM64 (Apple Silicon). Building x64 on it is cross-compiling.
          # We'll handle this in the build step.
          # No need to exclude arm64 on macos-latest as it's the native arch.
    runs-on: ${{ matrix.os }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Install dependencies
      run: |
        if [[ "${{ runner.os }}" == "Linux" ]]; then
          sudo apt-get update
          sudo apt-get install -y qemu-user-static imagemagick gcc-aarch64-linux-gnu gcc-arm-linux-gnueabihf gcc-x86-64-linux-gnu # Install cross-compilers and QEMU for testing
        elif [[ "${{ runner.os }}" == "macOS" ]]; then
          brew install imagemagick qemu
          # macOS runners are arm64 (Apple Silicon). For x64 build, clang will handle it.
        elif [[ "${{ runner.os }}" == "Windows" ]]; then
          choco install imagemagick -y
          # For Windows, we'll build x64 natively. Cross-compilation to other arches not covered here.
        fi
        
    - name: Generate test image
      run: |
        convert -size 100x100 gradient:blue-red test.jpg
        
    - name: Build for ${{ matrix.arch }} on ${{ runner.os }}
      run: |
        chmod +x build.sh
        # Pass the target architecture to build.sh
        # build.sh will detect if it's cross-compiling and use appropriate compilers if available
        ./build.sh build ${{ matrix.arch }}
      # Ensure build.sh output is captured for debugging
      shell: bash # Explicitly use bash for consistency

    - name: Run basic tests
      run: |
        # Test version command
        ./pit --version
        
        # Test image display (non-interactive mode)
        ./pit test.jpg --width 80
        
        # Test interactive mode (run for a short duration, then exit)
        # Using a simple echo 'q' | to simulate 'q' key press for graceful exit
        # This might not work perfectly for all interactive scenarios or if the program doesn't exit on 'q' fast enough
        # For more robust interactive testing, dedicated tools might be needed.
        if [[ "${{ runner.os }}" == "Linux" || "${{ runner.os }}" == "macOS" ]]; then
          echo "q" | ./pit test.jpg || true # || true to prevent step failure if timeout occurs
        elif [[ "${{ runner.os }}" == "Windows" ]]; then
          # Windows has different input handling. For CI, we might skip interactive test or use a more complex method.
          # For simplicity, just run and let it exit if it does.
          ./pit test.jpg # This will run in interactive mode until timeout or manual exit in a real terminal
        fi
      shell: bash # Explicitly use bash for consistency

    - name: Cross-architecture test (Linux only)
      if: runner.os == 'Linux' && (matrix.arch == 'x64' || matrix.arch == 'arm64')
      run: |
        # Test ARM64 binary on x64 runner using QEMU
        if [[ "${{ matrix.arch }}" == "x64" ]]; then
          log_info "Testing ARM64 binary on x64 Linux runner via QEMU..."
          ./build.sh build arm64 # Build ARM64 binary
          qemu-aarch64-static ./pit --version
          qemu-aarch64-static ./pit test.jpg --width 40 # Test image display
        # Test x64 binary on ARM64 runner using QEMU (if runner was ARM64)
        elif [[ "${{ matrix.arch }}" == "arm64" ]]; then
          log_info "Testing x64 binary on ARM64 Linux runner via QEMU..."
          ./build.sh build x64 # Build x64 binary
          qemu-x86_64-static ./pit --version
          qemu-x86_64-static ./pit test.jpg --width 40 # Test image display
        fi
      shell: bash # Explicitly use bash for consistency
      
  ios-test:
    runs-on: macos-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Setup iOS environment
      # This action sets up Xcode and a simulator.
      # Actual build for iOS is complex and usually involves Xcode projects.
      # This is a simplified example for CI context.
      run: |
        echo "Setting up iOS environment (simplified, real build needs Xcode project/toolchain)"
        # Get SDK path for simulator
        export SDKROOT=$(xcrun --sdk iphonesimulator --show-sdk-path)
        # Build for iOS simulator (arm64-apple-ios-simulator for Apple Silicon Macs)
        # For Intel Macs, it would be x86_64-apple-ios-simulator
        # Using clang directly, assuming it's available and configured for iOS targets
        clang -target arm64-apple-ios16.2-simulator -o pit_sim pit.c -framework Foundation -framework UIKit # Add frameworks if needed
        chmod +x pit_sim
        echo "Built pit_sim for iOS simulator"
        
    - name: Run on iOS simulator
      run: |
        # Find a suitable iPhone simulator
        SIMULATOR_UDID=$(xcrun simctl list devices | grep "iPhone 14" | grep -o -E '[0-9A-F]{8}(-[0-9A-F]{4}){3}-[0-9A-F]{12}' | head -n 1)
        if [ -z "$SIMULATOR_UDID" ]; then
          echo "No iPhone 14 simulator found, creating one..."
          SIMULATOR_UDID=$(xcrun simctl create "iPhone 14 CI" "iPhone 14" | tail -n 1)
        fi
        
        echo "Booting simulator: $SIMULATOR_UDID"
        xcrun simctl boot "$SIMULATOR_UDID"
        
        echo "Installing app to simulator..."
        # Create a dummy app bundle for simctl install
        mkdir -p pit.app
        cp pit_sim pit.app/pit_sim
        
        xcrun simctl install "$SIMULATOR_UDID" pit.app
        
        echo "Launching app on simulator..."
        # com.example.pit is a dummy bundle ID. In a real app, this would be your app's bundle ID.
        # This command might not show visual output in CI, but tests if it launches.
        xcrun simctl launch "$SIMULATOR_UDID" com.example.pit.pit_sim --version || true
        
        echo "Shutting down simulator..."
        xcrun simctl shutdown "$SIMULATOR_UDID"
      shell: bash
        
  release:
    runs-on: ubuntu-latest
    needs: [build-test, ios-test] # Ensure all tests pass before release
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') # Trigger on tag push like v1.0.0
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Install cross-compilers for release builds
      run: |
        sudo apt-get update
        sudo apt-get install -y gcc-aarch64-linux-gnu gcc-arm-linux-gnueabihf gcc-x86-64-linux-gnu g++-x86-64-linux-gnu mingw-w64 # For Windows cross-compilation
      
    - name: Build release assets
      run: |
        chmod +x build.sh
        mkdir release

        # Build Linux binaries
        log_info "Building Linux x86_64..."
        ./build.sh build x86_64
        mv pit release/pit-linux-x86_64

        log_info "Building Linux AArch64..."
        ./build.sh build aarch64
        mv pit release/pit-linux-arm64

        log_info "Building Linux ARMv7..."
        ./build.sh build armv7l
        mv pit release/pit-linux-armv7
        
        # Build Windows x86_64 binary (cross-compile from Linux)
        log_info "Building Windows x86_64..."
        # Ensure build.sh uses the correct cross-compiler (mingw-w64)
        # We pass CC explicitly here to ensure the right compiler is used for cross-compilation
        CC=x86_64-w64-mingw32-gcc ./build.sh build x86_64 # build.sh handles D_WIN32_WINNT and libs
        mv pit.exe release/pit-windows-x86_64.exe

        # macOS Universal Binary (requires macOS runner, so this is illustrative)
        # For a real release, you'd typically build this on a macos-latest runner
        # and pass the artifact to the release job.
        # For simplicity, we'll indicate it's a placeholder here.
        log_warning "macOS Universal Binary build is a placeholder. Typically built on macOS runner."
        # Example of how it *would* be built on a macOS runner:
        # ./build.sh build x86_64 && mv pit pit_x86
        # ./build.sh build arm64 && mv pit pit_arm
        # lipo -create -output release/pit-macos-universal pit_x86 pit_arm
        
    - name: Upload release assets
      uses: softprops/action-gh-release@v1
      with:
        files: release/*
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Automatically provided by GitHub Actions

